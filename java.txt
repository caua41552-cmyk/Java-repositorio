Aqui v√£o estar as anota√ß√µes de java, ebaaa

ANOTA√á√ÉO: O COME√áO, CRIA√á√ÉO DE VARI√ÅVEIS, SCANNER, PRINT

public class Arquivojava {
    public static void main(String[] args) {
    //Comece a programar aqui
    }
}

// isso aqui √© anota√ß√£o se voc√™ n√£o percebeu.
quando voc√™ for programar, tem que fazer tudo dentro do public static void main, no caso, no come√ßo kk

OBS: print sempre deve ser aspas duplas, java √© muita frescura.
System.out.print("Ol√° mundo!"); Esse √© o print, e tem que estar dentro do public static void l√°
System.out.printf("O n√∫mero digitado √© %d.", numero_1); o numero_1 √© uma vari√°vel, e no terminal ele vai mostrar o n√∫mero dessa vari√°vel
System.out.printf("%d + %f = %f", numero_1, Numero_2, (numero_1 + Numero_2)); tem que ter esses parenteses, e tamb√©m, no format voc√™ tem que usar %f caso seja um n√∫mero decimal mais um n√∫mero inteiro, no caso a soma deles
System.out.print("%d".formatted(num1)) Outra forma de usar o format a√≠
format: %s string %d inteiro (N√£o sei porque...) %f n√∫mero decimal %b para boleano


System.out.println("Ol√° mundo!"); esse print ele pula uma linha ap√≥s o texto!


int Numero_2 = 10; assim se cria uma vari√°vel, Numero_2 √© o nome
String Nome = "Paulo"; assim se cria uma vari√°vel como string, COM O "S" MAI√öSCULO, SEMPRE MAI√öSCULO 
double Peso = 67.00; quando usar o input para digitar um n√∫mero flutuante, ou dobro, voc√™ vai ter que digitar por exemplo 56,90 mas se for direto na vari√°vel, tem que usar ponto
tem o boleano, mas depois eu vejo isso kk
char ele recebe apenas um caracter, ele usa aspas simples
float √© mais limitado que o double para guardar casas decimais
long voc√™ usa esse quando o n√∫mero inteiro passar de 2.147.483.647
byte s√≥ guarda n√∫meros entre -128 e 127
short s√≥ guarda n√∫meros entre -32.768 e 32.767.
no arraylist a diferen√ßa √© que o Int vira Integer e o char vira Character, o resto, n√£o muda nada, eles s√≥ ficam com a inicial mai√∫scula

INPUT AQUI EM BAIXO!
import java.util.Scanner; se tem que importar essa biblioteca, porque n√£o existe input no java kakaka
Scanner input = new Scanner(System.in); voc√™ tem que criar uma vari√°vel, que eu nomeei de input, mas voc√™ pode nomear como quiser, e colcoar esse mesmo c√≥digo que aparece ap√≥s o =, ele serve para liberar o input
import java.nio.charset.StandardCharsets; Isso √© muito √∫til, porque ele vai permitir voc√™ digitar letras com acentua√ß√£o
Scanner input = new Scanner(System.in, StandardCharsets.UTF_8); Coloca isso no scanner ou input que ele vai permitir voc√™ digitar
String Nome = input.nextLine(); input √© o nome da vari√°vel que recebeu o Scanner, mas enfim

.nextLine() input para String .nextInt() input para n√∫meros inteiros .nextDouble() vari√°vel para numero do tipo double (flutuante).
Outra coisa, o java √© muito exigente, se voc√™ colocar o input para string numa vari√°vel do tipo numero inteiro vai dar erro... kk





ANOTA√á√ÉO: USO DO IF ELSE IF E ELSE

if (Numero % 2 == 0){
    System.out.print("√â um n√∫mero par!");
} else if (Numero % 2 == 1){
    System.out.print("√â um n√∫mero impar!");
} else {
    System.out.print("√â um n√∫mero inv√°lido!");
} 
√â assim que se utiliza if else if e else, o elif n√£o existe aqui... e em algumas outras linguagens!
String situacao = (media >= 7) ? "Aprovado": "N√ÉO PASSAR√ÅS"; tem esse outro jeito tamb√©m, mesma coisa do anterior, s√≥ que com menos linhas de c√≥digo.



USO DO switch

switch (local) {
    case 1:
        System.out.println("Ol√°");
        break;
            
    case 2:
        System.out.println("Bom dia!");
        break

    case 3:
        System.out.println("Como vai?");
        break

    default:
        break;
}
√© necess√°rio colocar o switch e nos () voc√™ deve colcoar o nome da vari√°vel,
case "SIM": isso voc√™ usa caso a vari√°vel v√° receber um valor como string

&& and || ou ! not


ANOTA√á√ÉO: WHILE E DO WHILE

while (contador < 10){
    System.out.println();
    System.out.printf("O contador est√° em %d", contador);
    contador ++;
// se quiser somar 2 ao inv√©s de 1 fa√ßa assim: contador += 2; inv√©s de ++;
}
o contador ++ vai somar mais um
obs: existe -- e talvez // e **, mas os √∫ltimos dois eu n√£o sei...
os operadores voc√™ sabe: ++(soma mais um) += 2 (soma mais dois, pode trocar o dois se quiser) -= (ele vai subtraindo) e o resto

Scanner scanner = new Scanner(System.in);

int senhaCorreta = 1234;
int tentativaUsuario = 0;
        
while (tentativaUsuario != senhaCorreta){
    System.out.print("Digite a senha (ou tente novamente): ");

    tentativaUsuario = scanner.nextInt();
            
    if (tentativaUsuario != senhaCorreta){
        System.out.print("Senha incorreta!");
        }  
    } 

        System.out.println("Acesso concedido! Voc√™ √© o mestre do Java.");

        scanner.close();
    }


DO while

do {
    System.out.print("Tentando estabilizar reator... Digite 'ok' quando conseguir: ");
    resposta = scanner.nextLine();
            
    if (resposta.equals("ok")){
        reatorEstavel = true;
    }

    } while (!reatorEstavel);
Resumo: O que estiver do "do" vai ser executado, e o while s√≥ diz quando parar
o !reatorEstavel √© a mesma coisa que reatorEstavel == False
while (!tentativa.equals(senhaCorreta)); ent√£o, ele vai executar enquanto a variavel tentativa receber um valor diferente da vari√°vel senhaCorreta

do {
    System.out.println("Escolha 0 ou 1:");
    confirmarGoogleDrive = scanner.nextInt();

    // Se a resposta for v√°lida, EU PARO o loop
    if (confirmarGoogleDrive == 0 || confirmarGoogleDrive == 1) {
        break; 
    }

    System.out.println("Op√ß√£o inv√°lida!");
} while (true); // Roda para sempre at√© encontrar o 'break'
olha o while true do python a√≠
boolen rodando = false;

do{ 
    int escolhaUsuario = scanner.nextInt();
            
    switch (escolhaUsuario) {
        case 1:
                System.out.print("Voc√™ comprou caf√©!");
                saldo -= 5;  
                break;

        case 2:
            System.out.printf("Saldo atual: %f.", saldo);
            break;
        
        case 0:
            System.out.print("Obrigado por comprar!") ;
            rodando = false;

        default:
            break;
    } while (rodando);
s√≥ para de excutar quando o boleano for verdadeiro





ANOTA√á√ÉO: For

for (int i = 1; i <= 10; i++){
    System.out.printf("Estrelinha numero: %d%n", i);
}
Eu preciso explicar algo aqui? eu acho que n√£o n√©?

int comeco = 5;
int fim = 50;
int pulo = 5;        
for (int i = comeco; i <= fim; i = pulo){
    System.out.printf("N√∫mero: %d.%n", i);
}
N√£o tem muito o que explicar aqui...

int balde = 10;
        
for (int i = balde; i >= 0; i--){
    System.out.printf("%d%n", i);
} 
a vari√°vel balde √© o come√ßo, se quisesse que fosse o fim era s√≥ fazer int i = 0; i = balde; i ++ ia funcionar

int numero = 10;
int fim = 15;
int idade = scanner.nextInt();
scanner.nextLine(); // Limpa o buffer (consome o Enter)
String nome = scanner.nextLine(); // Agora sim ele espera voc√™ digitar o nome.
quando voc√™ usa um input no int e o usu√°rio apertar enter, vai criar meio que uma linha invis√≠vel que vai igorar o pr√≥ximo input de next.line()
ent√£o, voc√™ tem que fazer isso para dar erro

for (; numero <= fim; numero ++){
    System.out.printf("%d%n",numero);
}
o ; no come√ßo ele serve para dizer que o come√ßo n√£o vai ser uma vari√°vel criada

for (int i = 1; i <= 10;){
    System.out.printf("%d%n",i);
    i++;
}

outro jeito de usar for a√≠, mas √© meio meh, se quiser colocar vari√°veis externas use sua criatividade





ANOTA√á√ÉO: M√©todos de string!

.toLowerCase() deixa tudo em minisculo
.toUpperCase() deixa tudo em maiusculo
.trim() √© o .strip do python, mas com outro nome
.replace("a", "b") isso aqui voc√™ entendeu, e se n√£o entendeu, N√ÉO √â POSS√çVEL
.equals() voc√™ viu l√° em cima 
.equalIgnoreCase() o anterior, se voc√™ digitasse uma letra mai√∫scula ou min√∫scula, daria erro, com esse n√£o
.startswith() Ele vai ver se a primeira palavra digitada vai ter o que tiver entre os parenteses
.endswith() ele vai ver se a √∫ltima palavra digitada vai terminar com o que tiver digitado nos parentes
.contains() ele verifica todo uma frase e verifica se vai ter uma palavra digitada
.isEmpty() ele verifica se o usu√°rio n√£o digitou nada kk
.isBlank() ele √© um isEmpty s√≥ que melhorado kk, o isEmpty s√≥ funciona se o usu√°rio digitar ""
"a".repeat(4) ele vai retornar aaaa literalmente aaaa
.indexOf("texto") ele vai procurar a palavra texto dentro da vari√°vel, do in√≠cio ao fim e retorna a posi√ß√£o dela 
.lastIndexOf("texto") ele vai fazer a mesma coisa do anterior, por√©m, ele vai ir do fim para o in√≠cio
.charAt(3) voc√™ d√° a posi√ß√£o no caso ali √© o 3, e ele vai retornar o que tem nessa posi√ß√£o
.formatted() ele √© tipo o format do python voc√™ vai ver
System.out.println("Usu√°rio %s | Level: %d".formatted(usuarioDigitar, numeroQualquer)); assim se usa o format
.split() voc√™ usa isso para separar itens da lista

System.out.printf("O usu√°rio digitou: %s.", usuarioDigitar.toUpperCase()); ASSiM QUE SE USA, no print
String usuarioDigitar = scanner.nextLine().toUpperCase(); esse, quando o usu√°rio digitar j√° vai estar em mai√∫scula, se voc√™ colocar essa vari√°vel no print j√° vai estar em MAI√öSCULO

String usuarioDigitar = scanner.nextLine().toUpperCase();
if (usuarioDigitar.equals("OLA")) Isso funciona, se o usu√°rio digitar "ola" ele vai entender da mesma forma que √© "OLA" mesmo o usu√°rio tendo digitado em minisculo

String usuarioDigitar = scanner.nextLine()
                               .toLowerCase()
                               .replace("a", "@")
                               .replace("e", "3")
                               .trim();





ANOTA√á√ÉO: Vetores!

Obs: esse primeiro vetor √© a lista do JAVA, parece uma tupla, mas √© uma lista.
String[] lista = new String[2];
lista[0] = "JO√£o";
lista[1] = "Paulo";

a lista no java √© limitada, o que estiver ali no string[x] vai ser a quantidade de itens que a lista vai guardar, nem mais nem menos
para adicionar √© lista[0] = "jo√£o"; e vai indo, 0, 1, 2
System.out.println("Total names: %d".formatted(lista.length)); isso √© para caso voc√™ queira contar os itens da lista, √© s√≥ fazer e n√£o por os "()"

String[] lista = {"Paulo", "Ricardo!"}; o jeito r√°pido, caso voc√™ j√° saiba os valores.
no java n√£o d√° para acrescentar e remover itens da lista, infelizmente... 
Int[lista] = {1, 4, 6}; cria uma lista int, se for bolean √© bolean e se for double √© double

for (String nomes: lista){
    System.out.println("%s nomes.".formatted(nomes));
} √© assim que usa o format com for

String[] nomes = {"Jo√£o", "Paulo", "Roberto"};
int[] idade = {15, 34, 9};

for (int i =0; i < nomes.length; i++){
    System.out.println("O seu nome √© %s e tem %d de idade.".formatted(nomes[i], idade[i]));
}
isso √© a coisa mais pr√≥xima que temos de for nomes, idade in range do python.

for (String nome : nomes) {
    if (nome.equals("Mario")) {
        System.out.println("Achei o %s! Parando a busca...".formatted(nome));
        break; // Sai do loop na hora
    }
O break ele vai quebrar quando achar o nome Mario,
daria para colocar um continue, se fizesse !nome.equal("Mario") iria prosseguir at√© achar o nome mario.

String[] produtos = {"Monitor", "Teclado", "Rato", "Auscultadores"};
int[] quantidade = {5, 0, 12, 0};

Exemplo de c√≥digo:
for (int i = 0; i < produtos.length; i++){
    if (quantidade[i] == 0){
        System.out.println("Estamos sem o produto %s no estoque, pe√ßo desculpas.".formatted(produtos[i], quantidade[i]));
    } else {
        System.out.println("Produto: %s || Estoque: %d".formatted(produtos[i], quantidade[i]));
    }
}

String nomes = "Jo√£o, Paulo, Jonas, Andr√©";
String[] lista = nomes.split(",");
total += numero[i];

use isso para mostarar os itens da lista: println("As frutas da lista s√£o: %s".formatted(String.join(",", lista)));
ABAIXO EST√Å A LISTA PURA DO JAVA, E PARA MOSTRAR ELA NO PRINT TEM QUE IMPORTAR A BIBLIOTECA DO ArrayList
que palha√ßada, para os valores da lista aparecerem no print, tem que usa biblioteca...
String frutas = "abobora, banana, ma√ß√£";
String[] pedaco = frutas.split(",");

System.out.print("Os itens na lista: %s".formatted(Arrays.toString(pedaco)));
o .split ele serve para separar os elementos, antes era apenas abobora, banana, maca, mas agora se eu quiser acessar banana eu posso, porque n√£o s√£o mais √∫nicos



ANOTA√á√ÉO: ArrayList
antes de tudo voc√™ tem que importar: 
import java.util.ArrayList; 
ArrayList<Integer> = new ArrayList<>(); isso cria uma arraylist do tipo inteiro.
OBS: PARA DEFINIR OUTROS TIPOS DE ARRAY LIST, OS √öNICOS QUE MUDAM S√ÉO O INT E O CHAR, INT VIRA INTEGER E O CHAR VIRA CHARACTER
E TAMB√âM, N√ÉO MUDA NADA O RESTO, O "double" VIRA "Double" ou seja, inicial mai√∫scula

adicionar: .add()
pegar: .get()
substituir: .set() 
remover: .remove()
tamanho: .size() ele vai retornar a quantidade de elementos que tem em uma lista

nomes.add("Jo√£o");
nomes.add("Juninadsfasdf");
nomes.add("asdlk√ßfjasd√ßlkfja");
idade.add(5);
//As duas formas de usar o remove abaixo
nomes.remove(1); // Esse ele remove pela posi√ß√£o, ou seja, vai remover o segundo elemento, posi√ß√£o, 0, 1, 2, lembra?
nomes.remove("asdlk√ßfjasd√ßlkfja"); // Esse √© digitando diretamente o nome do item
nomes.set(0, "Pedro");
nomes.size();

System.out.println("%s e %d".formatted(nomes.get(0), idade.get(0)));
Tem que ter esse .get se quiser mostrar o item da lista kk

ArrayList<String> lista = new ArrayList<>(1000);  isso cria uma lista capaz de guardar mil itens, isso funciona
arraylist come√ßa com uma capacidade de 10 e vai se expandindo conforme aumenta, ou seja, se tiver um 11 elemento a lista ela se expande
bem, caso voc√™ coloque lista 2 = lista 1, e voc√™ mudar algo na lista 2 na lista 1 vai mudar tamb√©m

String nome = scanner.nextLine();
nomes.add(nome); isso aqui funciona, o usu√°rio digita e depois √© acrescentado na arraylist

nomes.add(scanner.nextLine()); esse jeito funciona tamb√©m kk



ANOTA√á√ÉO: "DICION√ÅRIO"
Primerio importe: import java.util.HashMap;
HashMap <String, String> usuarios = new HashMap<>(); assim se cria um HashMap
usuarios.put("Paulo", "Banana"); assim que se coloca um item no dicion√°rio, a chave √© paulo, e o valor, banana
System.out.println("A fruta √©: %s".formatted(usuarios.get("Paulo"))); assim que se faz para mostrar o valor banana

L√° vem comando
.put("Chave", 3) ele vai colocar a chave Chave dentro do hasmap, com o valor 3
.get("Chavenome") aqui ele vai pegar o valor da chave que estiver nos parenteses
.containsKey("paulo") ele vai ver se dentro do HashMap possui a chave paulo, se n√£o tiver ele retorna false, se tiver true
.remove("Ola") ele vai remover a chave ola, e o valor dela
.clear() ele remove todos os itens do dicion√°rio, todos 
.isEmpty() ele verifica se o dicion√°rio est√° vazio, se estiver, ele vai retornar true, se n√£o, ele vai retornar false
.putIfAbsent(chave, valor) ele verifica se tem a chave valor, se tiver ele n√£o faz nada, se n√£o existir, ele vira um put kk
.replace("key", "valor") ele troca o valor que a chave key tinha antes por valor 
.size() ele conta quantos itens tem na lista

exemplo usando todos os comandos:
HashMap <String, String> usuarios = new HashMap<>(); 

usuarios.put("Jo√£o", "banana");
usuarios.put("Gabriel", "Morango");
usuarios.put("Jonas", "Peixe");
usuarios.remove("Gabriel");
usuarios.putIfAbsent("Lucas", "ameixa");
usuarios.replace("Jo√£o", "Manga");
int termosQuantidade = usuarios.size();
boolean vF = usuarios.isEmpty();

System.out.println("O Gabriel ainda existe? " + usuarios.containsKey("Gabriel"));
System.out.println("O dicion√°rio est√° vazio? %b".formatted(vF));
System.out.println("O dicion√°rio possui %d itens.".formatted(termosQuantidade));
System.out.println("%s".formatted(usuarios.get("Jonas")));
usuarios.clear()

Uso do for:
    
MOstra apenas chave
for (String chave: usuarios.keySet()){
    System.out.println("Chave: %s".formatted(chave));
}

Mostra apenas os valores das chaves
for (String senha: usuarios.values()){
    System.out.println("Valores = %s".formatted(senha));
}

Melhor jeito para mostrar a chave e o valor dela
for (var entrada: usuarios.entrySet()){
    System.out.println("Usu√°rio: %s ||| senha: %s ".formatted(entrada.getKey(), entrada.getValue()));
}

import java.util.Map; tem que importar essa biblioteca para fazer isso
for (Map.Entry<String, String> entrada: usuarios.entrySet()){
    System.out.println("Usu√°rio: %s ||| senha: %s ".formatted(entrada.getKey(), entrada.getValue()));
}





ANOTA√á√ÉO: Convers√£o de TIPOS

String numeroPontos = scanner.nextLine();
int numeroConvertido = Integer.parseInt(numeroPontos);
pontuacao.add(numeroConvertido);
isso ele serve para converter uma string em numero inteiro, mas eu n√£o vou saber explicar como
isso resolve o problema do enter invis√≠vel

Convers√£o de TIPOS
exemplos de convers√£o
1:
Scanner scanner = new Scanner(System.in);

System.out.print("Digite dois n√∫meros na mesma linha:");
String numeros = scanner.nextLine();
String[] nums = numeros.split(" ");
int num1 = Integer.parseInt(nums[1]);
int num2 = Integer.parseInt(nums[2]);

System.out.println("A soma entre %d e %d √© igual a %d.".formatted(num1, num2, (num1 + num2)));
scanner.close();
para transformar string em outras coisas usando esse .parse √© simples
exemplo para transformar string em double:  Double.parseDouble(var) simplesmente isso kk

2- casting (convers√£o entre n√∫meros)
double preco = 19.99;
int precoInteiro = (int) preco; // Voc√™ "fatiou" a v√≠rgula fora!

System.out.println(precoInteiro); // Vai imprimir 19

byte -> short -> char -> int -> long -> float -> double
se subir a escada, n√£o usa casting, se descer, sim





ANOTA√á√ÉO: Fun√ß√µes

para criar uma fun√ß√£o a gente faz public static void algo (String hum){}
voc√™ faz isso fora do public static void main
public static void (int var){} (int var) serve para dizer que a vari√°vel a ser digitada vai ser inteira voc√™ usa para criar uma fun√ß√£o que s√≥ mostra coisas na tela 
public static int voc√™ usa para fazer algum c√°lculo e e retornar um valor int
public static string existem outros tamb√©m, n√£o vou entrar em m√©ritos.

public static void main(String[] args) {
    Scanner scanner = new Scanner (System.in);
        
    System.out.println("Digite um n√∫mero: ");
    int usuario = scanner.nextInt();
    dobro(usuario);

    System.out.print("O dobro do n√∫mero %d √© %d.".formatted(usuario, dobro(usuario)));
    scanner.close();
}

public static int dobro(int num1){
    return num1 * 2;
}

exemplo de c√≥digo, return voltoooou AEEEE

outra forma de usar o print:

int dobro = dobro(usuario);
System.out.print("O dobro do n√∫mero %d √© %d.".formatted(usuario, dobro));
voc√™ cria uma vari√°vel que vai receber o valor retornado da fun√ß√£o/m√©todo dobro
N√ÉO USE O RETURN NULL, SE FOR CRIAR UMA FUN√á√ÉO QUE N√ÉO RETORNA UM VALOR, USE O PUBLIC STATIC VOID, SEU ANIMALAL
Voc√™ nunca vai usar o return null; voc√™ usa quando quer que a fun√ß√£o n√£o retorne nada

package projeto; // Nome da pasta que acabamos de criar

public class Heroi {
    public String nome;
    public int nivel;

    // Construtor para facilitar a cria√ß√£o
    public Heroi(String nome, int nivel) {
        this.nome = nome;
        this.nivel = nivel;
    }

    public void status() {
        System.out.println("üõ°Ô∏è Her√≥i: " + nome + " | N√≠vel: " + nivel);
    }
}

package projeto; // Mesma pasta, mesmo pacote

public class Start {
    public static void main(String[] args) {
        // Criando o her√≥i usando o arquivo Heroi.java
        Heroi meuHeroi = new Heroi("Slayer C", 99);

        System.out.println("--- Iniciando Jornada ---");
        
        // Chamando o m√©todo que est√° no outro arquivo
        meuHeroi.status();
        
        System.out.println("O sistema de importa√ß√£o funcionou!");
    }
}

Exemplo de java poo... e com importa√ß√£o de um arquivo
quando for imporar um arquivo, nos dois arquivos voc√™ tem que usar import package, nos dois
na linha Heroi meuHeroi = new Heroi("A", 99), o Heroi serve para dizer, √≥, isso vai sair do outro arquivo, sem ela n√£o d√° para chamar o m√©todo
o new serve para colocar os valores nos parenteses e o Heroi() n√£o preciso explicar n√©? kk
para usar o this. one, voc√™ tem que fazer o public String nome; e outras coisas, porque sen√£o n√£o d√° para usar o .this
o .thisnome = nome; √© semelhante ao .self do python 

\\Isso aqui √© outro arquivo, caso esteja se perguntando kk, esse e o outro
package javaestudos;
// O 'extends' diz que tudo que o Conversor tem, a ContaEspecial tamb√©m ter√°!
public class ContaEspecial extends Conversor {
    public double limite;

    public ContaEspecial(String dono, double saldo, double limite) {
        // O 'super' chama o construtor da classe m√£e (Conversor)
        // Ele envia o dono e o saldo para o molde original
        super(dono, saldo); 
        this.limite = limite;
    }

    public void exibirLimite() {
        System.out.println("Seu limite de cr√©dito √©: R$" + this.limite);
    }
}

a primeira linha est√° dizendo que a classe ContaEspecial vai receber todos os self da classe Conversor, que est√° em outro arquivo kk
o super() serve para dizer, pega os valores da classe Conversor
o super() tem que estar acima de todos, 

    @Override
    public void status() {
    // Aqui est√° o pulo do gato!
    System.out.println("--- STATUS DE GUERREIRO ---");
    System.out.println("Nome: " + this.nome);
    System.out.println("N√≠vel: " + this.level);
    System.out.println("Poder de Ataque: " + this.forca);
}

o m√©todo status j√° existia, o polimorfismo √© esse override, √© literalmente isso kaakaka 

package javaestudos;

public class Conversor {
    // 1. Atributos PRIVADOS: Ningu√©m do Main toca neles diretamente
    private String nome;
    private int level;

    public Conversor(String nome, int level) {
        this.nome = nome;
        this.level = level;
    }

    // --- O M√âTODO GET (O Interfone/Leitura) ---
    // Ele serve apenas para "retornar" o valor para quem pediu
    public String getNome() {
        return this.nome;
    }

    // --- O M√âTODO SET (A Portaria/Escrita) ---
    // Aqui n√≥s colocamos uma REGRA: o n√≠vel n√£o pode ser menor que 1
    public void setLevel(int novoLevel) {
        if (novoLevel >= 1) {
            this.level = novoLevel;
            System.out.println("Level alterado para " + novoLevel);
        } else {
            System.out.println("ERRO: O level " + novoLevel + " √© inv√°lido! Mantendo o anterior.");
        }
    }

    // Get para o Level tamb√©m, sen√£o o Main n√£o consegue ler
    public int getLevel() {
        return this.level;
    }
}

t√° a√≠ um exemplo de get e set, 

FAZ EXERC√çCIO DE ENCAPSULAMENTO E GET E SET, E DE POLIMORFISMO, E ESTUDA SOBRE O FINAL O PROTECTED E PRIVATE
FAZ EXERC√çCIO DE ENCAPSULAMENTO E GET E SET, E DE POLIMORFISMO, E ESTUDA SOBRE O FINAL O PROTECTED E PRIVATE
FAZ EXERC√çCIO DE ENCAPSULAMENTO E GET E SET, E DE POLIMORFISMO, E ESTUDA SOBRE O FINAL O PROTECTED E PRIVATE
FAZ EXERC√çCIO DE ENCAPSULAMENTO E GET E SET, E DE POLIMORFISMO, E ESTUDA SOBRE O FINAL O PROTECTED E PRIVATE
FAZ EXERC√çCIO DE ENCAPSULAMENTO E GET E SET, E DE POLIMORFISMO, E ESTUDA SOBRE O FINAL O PROTECTED E PRIVATE